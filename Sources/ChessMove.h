#pragma once

#include "ChessCommon.h"
#include "ChessObject.h"

namespace ChessEngine
{
	class ChessGame;
	class ChessPiece;

	class CHESS_ENGINE_API ChessMove : public ChessObject
	{
	public:
		ChessMove();
		virtual ~ChessMove();

		// Note that failure here ideally wouldn't put the board into a bad state, but if everything
		// is programmed correctly, a chess move should never fail to be done or undone, because the
		// only chess moves that should be applied are those generated by the chess pieces themselves.
		virtual bool Do(ChessGame* game) = 0;
		virtual bool Undo(ChessGame* game) = 0;

		virtual std::string GetDescription() const;
		virtual int GetSortKey() const;

		virtual bool WriteToStream(std::ostream& stream) const override;
		virtual bool ReadFromStream(std::istream& stream) override;

		bool WritePiece(std::ostream& stream, const ChessPiece* piece) const;
		bool ReadPiece(std::istream& stream, ChessPiece*& piece) const;

		ChessVector sourceLocation;
		ChessVector destinationLocation;
	};

	class CHESS_ENGINE_API Travel : public ChessMove
	{
	public:
		Travel();
		virtual ~Travel();

		virtual bool Do(ChessGame* game) override;
		virtual bool Undo(ChessGame* game) override;

		virtual Code GetCode() const override;

		virtual std::string GetDescription() const override;
		virtual int GetSortKey() const override;
	};

	class CHESS_ENGINE_API Capture : virtual public ChessMove
	{
	public:
		Capture();
		virtual ~Capture();
		
		virtual bool Do(ChessGame* game) override;
		virtual bool Undo(ChessGame* game) override;

		virtual std::string GetDescription() const override;
		virtual int GetSortKey() const override;

		virtual bool WriteToStream(std::ostream& stream) const override;
		virtual bool ReadFromStream(std::istream& stream) override;

		virtual Code GetCode() const override;

		ChessPiece* capturedPiece;
	};

	class CHESS_ENGINE_API Castle : public ChessMove
	{
	public:
		Castle();
		virtual ~Castle();

		virtual bool Do(ChessGame* game) override;
		virtual bool Undo(ChessGame* game) override;

		virtual std::string GetDescription() const override;
		virtual int GetSortKey() const override;

		virtual bool WriteToStream(std::ostream& stream) const override;
		virtual bool ReadFromStream(std::istream& stream) override;

		virtual Code GetCode() const override;

		ChessVector rookSourceLocation;
		ChessVector rookDestinationLocation;
	};

	class CHESS_ENGINE_API Promotion : virtual public ChessMove
	{
	public:
		Promotion();
		virtual ~Promotion();

		virtual bool Do(ChessGame* game) override;
		virtual bool Undo(ChessGame* game) override;

		virtual std::string GetDescription() const override;
		virtual int GetSortKey() const override;

		virtual bool WriteToStream(std::ostream& stream) const override;
		virtual bool ReadFromStream(std::istream& stream) override;

		virtual Code GetCode() const override;

		void SetPromotedPiece(ChessPiece* piece);

	protected:

		ChessPiece* newPiece;
		ChessPiece* oldPiece;

		char cachedDesc[128];
	};

	// Braving uncharted territory here with multiple inheritance!!
	class CHESS_ENGINE_API CapturePromotion : public Promotion, public Capture
	{
	public:
		CapturePromotion();
		virtual ~CapturePromotion();

		virtual bool Do(ChessGame* game) override;
		virtual bool Undo(ChessGame* game) override;

		virtual std::string GetDescription() const override;
		virtual int GetSortKey() const override;
		virtual Code GetCode() const override;

		virtual bool WriteToStream(std::ostream& stream) const override;
		virtual bool ReadFromStream(std::istream& stream) override;
	};

	class CHESS_ENGINE_API EnPassant : public ChessMove
	{
	public:
		EnPassant();
		virtual ~EnPassant();

		virtual bool Do(ChessGame* game) override;
		virtual bool Undo(ChessGame* game) override;

		virtual std::string GetDescription() const override;
		virtual int GetSortKey() const override;

		virtual bool WriteToStream(std::ostream& stream) const override;
		virtual bool ReadFromStream(std::istream& stream) override;

		virtual Code GetCode() const override;

		ChessVector captureLocation;
		ChessPiece* capturedPiece;
	};
}